# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' ergodic process simulator
#' @param agents integer specifying the number of agents 
#' @param rounds integer specifying the number of rounds
#' @param money double specifying initial money for agents 
#' @param win double specifying multiplier for money given a win (should be strictly positive)
#' @param loss double specifying multiplier for money given a loss (should be strictly positive)
#' @param prob double specifying probability of a win 
#' @return a matrix of agent money per round where rows are rounds and columns are agents 
ergodic_sim <- function(agents, rounds, money, win, loss, prob) {
    .Call(`_misccpp_ergodic_sim`, agents, rounds, money, win, loss, prob)
}

#' gamblers ruin simulation 
#' @param n_runs integer number of simulations
#' @param money_start double initial money 
#' @param money_end double money to be achieved 
#' @param p_win double win probability 
#' @param risk_adjust double proportion of money to bet
#' @param adaptive bool indicating whether to use adaptive betting (based on bayesian estimation of win probability)
#' @param prior_beta integer vector holding alpha and beta parameters of the p_win prior 
#' @return a List holding a vector indicating rounds and a vector indicating busts for each run 
ruin_sim <- function(n_runs, money_start, money_end, p_win, risk_adjust, adaptive, prior_p_win) {
    .Call(`_misccpp_ruin_sim`, n_runs, money_start, money_end, p_win, risk_adjust, adaptive, prior_p_win)
}

#' kmean 
#' @param points a matrix where rows are individual points and columns are their coordinates 
#' @param k integer specifying the number of clusters to search for 
#' @param max_iter integer specifying the maximum number of iterations to run the algorithm for 
#' @return a list with an integer vector specifying the cluster assignment of points and a matrix with centroid point coordinates for each cluster
kmean <- function(points, k, max_iter) {
    .Call(`_misccpp_kmean`, points, k, max_iter)
}

#' Link-tracing Gibbs sampler
#' @param links_list list of between unit edges
#' @param wave integer vector of rds wave units were sampled in
#' @param name integer vector of unit ids
#' @param y_samp matrix pass through of adjecency matrix generated in get_study_est_linktrace
#' @param strata integer stratum id of each unit
#' @param n_strata integer number of unique strata
#' @param n_waves integer number of sampling waves
#' @param total integer total size of the population
#' @param chain_samples integer number of samples per MCMC chain
#' @param chain_burning integer number of burnin samples per MCMC chain
#' @param prior_n integer power law prior for population size
#' @param prior_l double vector of dirichilet priors for stratum membership
#' @param prior_b integer beta distribution prior for unit links
#' @param n_0 integer initial value for n
#' @param l_0 double vector initial values for l
#' @param b_0 double matrix initial values for b
#' @param n_samples number of samples to draw
#' @param progress bool indicating whether to display progress bar
#' @return a vector of vectors with n_samples population size samples
#' @keywords internal
lt_gibbs_cpp <- function(links_list, wave, name, y_samp, strata, n_strata, n_waves, total, chain_samples, chain_burnin, prior_n, prior_l, prior_b, n_0, l_0, b_0, n_samples, progress) {
    .Call(`_misccpp_lt_gibbs_cpp`, links_list, wave, name, y_samp, strata, n_strata, n_waves, total, chain_samples, chain_burnin, prior_n, prior_l, prior_b, n_0, l_0, b_0, n_samples, progress)
}

add_par <- function(n, ncores) {
    .Call(`_misccpp_add_par`, n, ncores)
}

add_seq <- function(n) {
    .Call(`_misccpp_add_seq`, n)
}

write_vec_par <- function(x, y, ncores) {
    .Call(`_misccpp_write_vec_par`, x, y, ncores)
}

#' pareto process simulator 
#' @param pop_size integer specifying the number of agents
#' @param mon integer vector specifying initial money for each agent
#' @param prop double vector specifying the win probability for each agent 
#' @param iter integer specifying the number of iterations to run 
#' @return a list of agent money vectors 
pareto_sim <- function(pop_size, mon, prop, iter) {
    .Call(`_misccpp_pareto_sim`, pop_size, mon, prop, iter)
}

